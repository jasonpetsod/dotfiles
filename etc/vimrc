set nocompatible

" backups are lame
set nobackup
set nowritebackup

" UI
set ruler
set showcmd
set background=dark
set wildmode=list:longest
set backspace=indent,eol,start
set scrolloff=1
set hidden
syntax on

" search options
set incsearch
set ignorecase
set smartcase
set report=0

" whitespace formatting
set autoindent
set tabstop=4
set shiftwidth=4
set shiftround
set nowrap
set expandtab
set smarttab
set textwidth=78
set list
set listchars=tab:>-,trail:.
set nojoinspaces
filetype plugin indent on

" modelines
set modeline
set modelines=5

" spelling
set spelllang=en_us,en_gb
set spellfile=~/.spell.add

let @b = "============================================================================"

" ============================================================================
" GNU screen titles
" ============================================================================

if &term == "screen"
    function! SetTitle(s)
        let s = a:s

        if strlen(s) == 0
            let s = "(no name)"
        endif

        let &titlestring = s
    endfunction

    set t_ts=k
    set t_fs=\
    set title

    " actually set the title
    call SetTitle(expand("%:t"))

    " make sure the title changes if filename changes
    au! BufWritePost * call SetTitle(expand("%:t"))

    " change title when buffer changes
    au! BufEnter * call SetTitle(expand("%:t"))
endif

" ============================================================================
" mappings/abbreviations
" ============================================================================

" remappings for my silly mistakes
imap [:w <ESC>:w<RETURN>
imap [:W <ESC>:w<RETURN>
imap {:w <ESC>:w<RETURN>
imap {:W <ESC>:w<RETURN>
cabbrev W w
cabbrev Q q

" paragraph reformatting
vnoremap Q gq
nnoremap Q gqap

" run make
nnoremap <C-e> :w!<RETURN>:make<RETURN>

" paste/nopaste toggle
set pastetoggle=<F7>

" spell/nospell toggle
nnoremap <SILENT> <F6> :set nospell!<RETURN>
inoremap <SILENT> <F6> <ESC>:set nospell!<RETURN>a


let mapleader = ","

" quicker :w, :wq
map <LEADER>, :w<RETURN>
map <LEADER>. :wq<RETURN>

" export syntax-highlighted file
map <LEADER>H :runtime! syntax/2html.vim<RETURN>

" reload/edit vimrc
map <LEADER>v :split ~/.vimrc<RETURN>
map <LEADER>r :source ~/.vimrc<RETURN>

" ============================================================================
" commenting
" ============================================================================

" set up commenting
function! Commenting(comment_char, ...)
    if exists("a:1")
        " block commenting
        let g:block_commenting = 1
        let g:comment_char = a:comment_char
        let g:end_comment_char = a:1
    else
        " line commenting
        let g:block_commenting = 0
        let g:comment_char = a:comment_char

    endif

    vnoremap ] :call Comment()<RETURN>
    vnoremap [ :call Uncomment()<RETURN>

    let @a = g:comment_char . " " . @b . "\n"
endfunction

function! Comment() range
    if g:block_commenting
        " escape regex metacharacters
        let comment_char = escape(g:comment_char, "*")
        let end_comment_char = escape(g:end_comment_char, "*")

        " start comment block
        let line = getline(a:firstline)
        call setline(a:firstline, substitute(line, '^', comment_char, ''))

        " end comment block
        let line = getline(a:lastline)
        call setline(a:lastline, substitute(line, '$', end_comment_char, ''))
    else
        " line commenting
        execute "'<,'>s@^@" . g:comment_char . "@e"
    endif
endfunction

function! Uncomment() range
    if g:block_commenting
        " escape regex metacharacters
        let comment_char = escape(g:comment_char, "*")
        let end_comment_char = escape(g:end_comment_char, "*")

        " remove start
        let line = getline(a:firstline)
        call setline(a:firstline, substitute(line, '^' . comment_char, '', ''))

        " remove end
        let line = getline(a:lastline)
        call setline(a:lastline, substitute(line, end_comment_char . '$', '', ''))
    else
        " line commenting
        execute "'<,'>s@^" . g:comment_char . "@@e"
    endif
endfunction

" ============================================================================
" filetype-specific
" ============================================================================

" C files
augroup c
    au!
    au FileType c call Commenting('/*', '*/')
augroup END

" C header files
augroup cpp
    au!
    au FileType cpp call Commenting('/*', '*/')
    au FileType cpp map <LEADER>o :set ft=objc<RETURN>
augroup END

" CSS files
augroup css
    au!
    au FileType css call Commenting('/*', '*/')
augroup END

" HTML files
augroup html
    au!
    au FileType html call Commenting('<!--', '-->')
augroup END

" LaTeX files
augroup tex
    au!
    au BufNewFile,BufReadPost *.tex set ft=tex

    au FileType tex nnoremap <C-t> :w!<RETURN>:!pdflatex "%"<RETURN>
    au FileType tex set spell
    au FileType tex call Commenting('%')
augroup END

" Makefiles
augroup makefile
    au!
    au FileType make call Commenting('#')
    au FileType make set nolist
augroup END

" mail messages
augroup mail
    au!
    au FileType mail set notitle
    au FileType mail set textwidth=76
augroup END

" Objective-C files
augroup objc
    au!
    au BufNewFile,BufReadPost *.m set ft=objc
    au FileType objc call Commenting('/*', '*/')
    au FileType objc set cindent
augroup END

" Perl scripts
iab pl! <ESC>:r ~/.vim/perl_skel<RETURN>:set ft=perl<RETURN>ggdd/%start%/<RETURN><ESC>ddO

augroup perl
    au!
    au FileType perl iab uddmp use Data::Dumper;<RETURN>print Dumper
    au FileType perl iab ddmp print Dumper
    au FileType perl call Commenting('#')
augroup END

" PHP scripts
augroup php
    au!
    au FileType php call Commenting('//')
augroup END

" Python scripts
augroup python
    au!
    au FileType python call Commenting('#')
augroup END

" shell scripts
augroup shell
    au!
    au FileType sh call Commenting('#')
augroup END

" text files
augroup text
    au!
    au FileType text set spell
augroup END

" vim scripts
augroup vim
    au!
    au FileType vim call Commenting('"')
augroup END
